Реализация декартова дерева на языке Haskell
============================================

_Этот README составлен с использованием [Markdown] [md] — специального легковесного языка разметки.
Его можно читать в блокноте или преобразовать в HTML (например, с помощью [Dingus] [d])._

[md]: http://daringfireball.net/projects/markdown
[d]: http://daringfireball.net/projects/markdown/dingus

Описание пакета
-----------------

Декартово дерево -- это сбалансированное двоичное дерево поиска, основанное на рандомизации (алгоритмы
работы с ним описаны в разделе «Как работает декартово дерево»). Пакет содержит
модуль, реализующий эту структуру данных, и несколько вспомогательных файлов.

Полный перечень содержимого:

* CartesianTree.hs — собственно модуль, который экспортирует тип данных CTree и несколько функций
для работы с ним.
* Main.hs — программа-бенчмарк, которая генерирует различные наборы тестовых данных, строит по ним
дерево и собирает статистику для последующей обработки.
* data/stats.txt — результат работы бенчмарка на локальной машине. Вследствие рандомизированной
природы декартова дерева конкретные цифры могут отличаться даже между двумя последовательными запусками
бенчмарка. Этот файл предназначен не для чтения человеком, а для последующей его обработки программой
построения графиков.
* data/{heights.svg, times.svg} — графики высоты дерева и времени работы в зависимости от количества
и типа вставляемых узлов (формат svg). Бенчмарк проводился на следующих последовательностях целых чисел:
 * возрастающая последовательность;
 * убывающая последовательность;
 * случайные числа.
 
 Количество узлов изменялось от 1000 до 50000 с шагом 1000. Графики построены программой [Ploticus] [pl].
* data/build-graphs.bat — скрипт для создания графиков из файла stats.txt. Требует установленного
Ploticus.

Запуск бенчмарка
----------------

Сначала необходимо скомпилировать исходные файлы командой `ghc --make Main.hs`. После этого нужно запустить
исполняемый файл, который выдаст на стандартный вывод нужную статистику: `Main.exe > data\stats.txt`.
При наличии установленного Ploticus можно перейти в каталог `data` и вызвать там скрипт `build-graphs.bat`
(ожидается, что в этом же каталоге будет находиться файл `stats.txt`).

Формат файла stats.txt следующий: в каждой строке сначала идёт количество узлов, вставленных в дерево,
затем через пробел идут пары `высота время`, каждая пара соответствует одному типу входных данных.

Как работает декартово дерево
-----------------------------

_NB: по своему строению декартово дерево (cartesian tree) идентично хорошо известной структуре данных [«дуча» (treap)] [treap].
Однако традиционные алгоритмы вставки и удаления узлов для дучи используют вращения; аналогичные же операции в
декартовом дереве реализованы совсем по-другому. Строго говоря, на этом различия между декартовым деревом и дучей
исчерпываются; все результаты из статей, посвящённых дучам, можно применять и к декартовым деревьям._

Известно, что при вставке `n` случайных узлов в бинарное дерево поиска его ожидаемая высота будет равна `O(log n)`.
Однако специальным образом подобранный набор узлов (например, возрастающая последовательность целых чисел)
заставит дерево «выродиться» в связный список с высотой `O(n)`. Декартово дерево пытается избежать такого наихудшего
случая, используя стратегию рандомизации.

Будем хранить в каждом узле дерева вместе с ключом `key` хранить случайным образом назначенный приоритет `pri`
и поддерживать следующие два инварианта:

* относительно `key` наше двоичное дерево является деревом поиска;
* относительно `pri` оно является [кучей] [heap].

Если не вдаваться в детали, то соблюдение этого условия помогает поддерживать дерево достаточно сбалансированным
(ожидаемая высота пропорциональна логарифму от количества узлов). Заметим, что все операции, не изменяющие дерево
(например, поиск элемента), такие же, как и в классическом двоичном дереве поиска.

Перейдём к поддержанию инвариантов при модифицирующих операциях. Введём две операции над декартовыми деревьями, с помошью
которых легко реализовать вставку и удаление.

* Операция `split`, разбивающая одно декартово дерево на два. Она получает на вход дерево и ключ `x`, по которому производится
разбиение, и возвращает деревья `L` и `R`. В дерево `L` попадают все узлы
с `key <= x`, в `R` — с `key >= x`.
* Операция `merge`, сливающая два декартовых дерева `L` и `R` в одно. Любой ключ `key` из `L` должен быть меньше либо
равен любому ключу `key` из `R`.

Обе операции работают за время, пропорциональное высоте входных деревьев (как мы знаем, логарифмической) и сохраняют все инварианты.
Их реализацию можно найти в файле CartesianTree.hs (они не являются частью публичного API и не выставляются наружу).

Теперь на основе `split` (разбиения) и `merge` (слияния) разработаем вставку и удаление.

* Вставка. Пусть в дерево `T` вставляется ключ `x`. Разобьём `T` по `x` на `L` и `R`. Создадим новое одноэлементное
дерево `M` со случайным `pri` и `key` = `x` (это тривиально). Теперь сольём `L` и `M`, и полученное дерево сольём
с `R`.
* Удаление (оно даже проще, чем вставка, что удивительно). Пусть удаляется узел `x`. Найдём в дереве 
поддерево `D` с корнем в узле `toDel` с `key` = `x`, сольём его левые и правые поддеревья и поставим результат вместо
`D`. Память, выделенную под узел `toDel`, соберёт сборщик мусора.

Нетрудно убедится, что все операции (вставка/удаление, разбиение/слияние):

1. Выполняются за ожидаемое логарифмическое время.
2. Реализуемы без потерь эффективности в рамках парадигмы функционального программирования (каждая операция возвращает новое дерево,
а сборщик мусора освобождает ненужную память).

[pl]: http://ploticus.sourceforge.net/
[treap]: http://en.wikipedia.org/wiki/Treap
[heap]: http://en.wikipedia.org/wiki/Binary_heap